# 关于Git分支

## 简介

从 Git 保存数据开始，要知道Git保存数据时不是文件的变化或者差异，而是一系列不同时刻的文件快照。再进行提交操作的时候，Git会保存一个提交对象，知道了Git保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。但不仅仅这样，该提交对象还包含了作者的姓名和邮箱，提交时输入的信息以及指向它父对象的指针。首次提交产生的提交对象没有父对象。普通提交操作产生的提交对象由一个父对象，而由多个分支合并产生的提交对象有多个父对象。

为了更加形象地来说明，我们假设现在由一个工作目录，里面包含了三个将要被暂存和提交的文件。暂存操作会为每一个文件计算校验和，然后会把当前版本的文建快照保存到Git仓库中(Git使用blob对象来保存它们)，最终将校验和加入到暂存区域等待提交。当使用git commit进行提交操作的时候，Git会首先计算每一个子目录的校验和，然后在Git仓库中保存这些校验和为树对象，随后，Git便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象的指针，如此一来，Git就可以在需要的时候重现此次保存的快照。

现在，Git仓库中有五个对象：三个blob对象（保存着文件快照）、一个树对象（记录着目录结构和blob对象索引）、一个提交对象（包含着指向前述树对象的指针和所有提交信息）。

做些修改后再次提交那么这次产生的提交对象会包含一个指向上次提交对象的指针。Git的分支，其实本质上仅仅是指向提交对象的可变指针，Git默认分支的名字是master，在多次提交操作之后，你其实已经有一个指向最后那个提交对象的master分支，他会在每次的提交操作中自动向前移动。它会在每次的提交操作中自动向前移动。

Git的master分支并不是一个特殊的分支，它就跟其他的分支完全没有区别，之所以几乎每一个仓库都有master分支是因为git init命令默认创建它，并且大多数人都懒得改动。。

## 分支创建

Git 是怎么创建新分支呢？很简单，它只是为你创建了一个可以移动的新的指针。比如创建一个testing分支，你需要使用`git branch`命令。`git branch testing`。这会在当前提交对象上创建一个指针。那么，git又是如何知道当前在哪一个分支上呢？也很简单，他有一个名为HEAD的特殊指针，注意它和其他版本控制系统的HEAD概念完全不同。在Git中，它是一个指针，指向当前所在的本地分支。注意创建后仅仅创建一个分支，并不会自动切换到分支上去。

可以使用 git log 命令查看各个分支当前所指的对象，提供这一功能的参数是 `--decorate`

## 分支切换

要切换到一个已经存在的分支，需要使用`git checkout`命令，`git checkout testing`这样 HEAD 就指向 testing分支了。那么，这样的实现方式会有什么好处呢？如果此时提交进行一次提交，你的testing分支将会向前移动，但是master分支却没有，它仍然指向运行git checkout时所指的对象，这就有意思了，现在我们切换回master分支。`git checkout master`这条命令做了两件事情，一是使HEAD指回master，二是将工作目录恢复成master分支所指向的文件快照内容。也就是说，现在做修改的话，项目将开始于一个比较旧的版本，这就是忽略testing分支所做的修改，以便于向另一个方向进行开发。

分支切换会改变目录中的文件，在切换分支的时候，一定要注意工作目录中的文件会改变。如果是切换到一个较为旧的分支，你的工作目录会恢复到该分支最后一次提交的样子。如果Git不能干净利落地完成这个任务，它将禁止切换分支。

这样，在两个分支方向上进行开发，项目的提交历史已经产生了分叉。因为新建了一个分支，并切换过去进行了一些操作，随后又切换回master分支进行了另外一些工作，上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟的时候将它们合并起来，而所有这些工作，你需要的命令只有branch、checkout、commit


你可以使用git log命令查看分叉历史。运行`git log --oneline --decorate --graph --all`会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。       

由于Git的分支实质上仅仅是包含所指对象校验和的文件，所以它的创建和销毁都异常高校，创建一个新分支就相当于向一个文件中写入 41 个字节。这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支的时候，将所有的项目文件都复制一遍，并保存到一个特定的目录。完成这样繁琐的过程通常需要好几秒中，有时甚至需要好几分钟，所需时间的长短完全取决于项目的规模。而在Git中任何规模的项目都能在瞬间创建新分支。同事由于每次提交都会记录父对象。所以寻找恰当的合并也是同样的简单和高效，这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。

## 分支的创建与合并

让我们来看一个简单的分支新建和分支合并的例子，实际工作中你可能会用到类似的工作流，你将经历以下步骤：

1. 开发某个网站
2. 为实现某个新的需求，创建一个分支
3. 在这个分支上开展工作

正在此时，你突然接到一个电话说由一个严重的问题需要紧急修补，此时将如下操作：

1. 切换到你的线上分支(production branch)
2. 为这个紧急任务新建一个分支，并在其中修复它。
3. 在测试通过后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支
4. 切换回最初工作的分支上继续工作

### 新建分支

首先假设正在项目上工作，并且已经有了一些提交，现在你已经决定要解决一个问题，想要创建一个分支并同时切换到那个分支上去，可以运行带有 -b 参数的 git checkout命令：`git checkout -b error`，你继续在error分支上工作并且做了一些提交，在此过程中，error分支不断向前推荐，因为你已经检出到该分支，也就是说你的 HEAD 指针指向了该分支。

现在你接到了电话有个紧急问题需要解决，有了git的帮助，你不必将这个紧急问题和error修改混在一起，你也不需要花大力气来还原关于error分支上的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支，你所要做的仅仅是切换回master分支。

但是在这么做之前，要留意当前工作目录和暂存区里哪些还没有被提交的更改，它可能会和你即将检出的分支产生冲突从而阻止git切换到该分支。最好的方法是，在你切换回分支之前，保持好一个干净的状态。有一些方法可以绕过这个问题（即，保存进度和修补提交）现在假设已经将所有的修改全部提交了，这时候可以切换回master分支了。

这个时候，你的工作目录和你开始error之前一模一样，你可以专心修复紧急问题了。请牢记：当你切换分支的时候，Git会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子，Git会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交的样子一模一样。

接下来，你要修复这个紧急问题，让我们建立一个针对该紧急问题的分支，在该分支上工作直到问题解决：`git checkout -b hotfix`。运行测试确保修复完毕，然后将其合并回你的master分支，并部署到线上。可以使用`git merge`命令来达到上述目的：
```shell
$git checkout master
$git merge hotfix
Updateing f42...3as
Fast-forward
    index.html | 2++
```

在合并的时候应当注意到了fast-forward这个词，由于当前master分支所指向的提交是你当前提交（有关hotfix）的直接上游，所以Git只是简单的将指针向前移动，换句话说，当你试图合并两个分支的时候，如果顺着分支走下去能够到达另一个分支，那么Git在合并的时候只会简单地将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做快进(fast-forward)

关于这个紧急问题的解决方案发布之后，你准备回到被打断的之前的工作中，然而，你应该首先删除hotfix分支，因为你已经不需要它了——master分支已经指向了同一个位置。你可以使用-d选项的git branch命令来删除分支：`git branch -d hotfix`。现在可以切换回你正在工作的error分支上继续你的工作。

由于你在 hotfix 分支上所做的工作并没有包含到 error 分支上，如果你需要拉取 hotfix 所做的修改，可以使用`git merge master`命令将master分支合并入error分支，或者也可以等到error完成其使命，再将其合并回master分支。

## 分支的合并

假设已经完成了error分支问题，并且打算将你的工作合并入master分支，为此需要合并error分支到master分支，这和你之前合并hotfix分支所做的工作差不多，只需要检出到你想合并入的分支，然后运行git merge命令。 这可能和之前的快进合并不一样，因为这种情况下，你的开发历史从一个更早的地方开始分叉开来(diverged)。因为master分支所在提交并不是error分支所在提交的直接祖先，Git不得不做一些额外的工作，出现这种情况的时候，Git会使用两个分支末端所指的快照以及这两个分支的工作组先，做一个简单的三方合并。

和之前将分支指针向前推荐不同的是，Git将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。这个被称作一次**合并提交**，它的特别之处在于它有不止一个父提交。需要注意的是，Git会自行决定选取哪个提交作为最优的共同祖先并以此来作为合并的基础。在一些古老的版本控制系统中，用户需要自己选择最佳的合并基础。Git的这个优势使得其合并操作上比其他系统要简单的多。

既然已经将修改合并进来了，此时不需要error分支，就可以删除这个分支了`git branch -d error`。

## 遇到冲突时的分支合并

有时候合并操作并不会很顺利，如果在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git就没有办法干净地合并它们。如果你关于error和hotfix的修改都涉及到了同一文件的同一个地方，在合并的时候就会产生冲突。此时Git做了合并，但是没有自动地创建一个新的合并提交，Git会暂停下来，等待你去解决合并产生的冲突。你可以在合并冲突后的任意时刻使用git status命令来查看那些因为包含合并冲突而处于未合并状态的文件。

任何因为包含合并冲突而有待解决的文件，都会以未合并状态标识处理啊。Git会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。出现冲突的文件会包含一些特殊区段。`>>>>>>>`。

当使用合并工具完成后，退出合并工具时，Git会询问刚才的合并是否成功，如果回答是则Git会暂存那些文件以表明冲突已经解决。如果已经确认合并完成，此时输入`git commit`来完成合并提交，如果对于默认情况不满意，信息不够充分，可以修改默认的提交信息，添加一些细节来给未来检视这个合并的读者一些帮助，告诉他们你是如何解决冲突的，以及理由是什么

## 分支管理

现在已经创建、合并、删除了一些分支，看一些常用的分支管理工具

git branch 命令不只是可以创建和删除分支，如果不加任何参数运行它，则会得到当前所有分支的一个列表。注意`*`字符表示现在检出的那个分支。如果腰缠看每一个分支的最后一次提交，可以运行`git branch -v`.`--merged`和`--no-merged`可以通过过滤列表，来显示已经合并或者尚未合并到当前分支的分支。

对于`git branch --merged`，可以看到哪些分支已经合并到当前分支。这时通常可以删除`git branch -d`那些已经合并的分支，因为你已经将它们的工作整合到了另一个分支，所以并不会丢失任何东西。

