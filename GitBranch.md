# 关于Git分支

## 简介

从 Git 保存数据开始，要知道Git保存数据时不是文件的变化或者差异，而是一系列不同时刻的文件快照。再进行提交操作的时候，Git会保存一个提交对象，知道了Git保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。但不仅仅这样，该提交对象还包含了作者的姓名和邮箱，提交时输入的信息以及指向它父对象的指针。首次提交产生的提交对象没有父对象。普通提交操作产生的提交对象由一个父对象，而由多个分支合并产生的提交对象有多个父对象。

为了更加形象地来说明，我们假设现在由一个工作目录，里面包含了三个将要被暂存和提交的文件。暂存操作会为每一个文件计算校验和，然后会把当前版本的文建快照保存到Git仓库中(Git使用blob对象来保存它们)，最终将校验和加入到暂存区域等待提交。当使用git commit进行提交操作的时候，Git会首先计算每一个子目录的校验和，然后在Git仓库中保存这些校验和为树对象，随后，Git便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象的指针，如此一来，Git就可以在需要的时候重现此次保存的快照。

现在，Git仓库中有五个对象：三个blob对象（保存着文件快照）、一个树对象（记录着目录结构和blob对象索引）、一个提交对象（包含着指向前述树对象的指针和所有提交信息）。

做些修改后再次提交那么这次产生的提交对象会包含一个指向上次提交对象的指针。Git的分支，其实本质上仅仅是指向提交对象的可变指针，Git默认分支的名字是master，在多次提交操作之后，你其实已经有一个指向最后那个提交对象的master分支，他会在每次的提交操作中自动向前移动。它会在每次的提交操作中自动向前移动。

Git的master分支并不是一个特殊的分支，它就跟其他的分支完全没有区别，之所以几乎每一个仓库都有master分支是因为git init命令默认创建它，并且大多数人都懒得改动。。

## 分支创建

Git 是怎么创建新分支呢？很简单，它只是为你创建了一个可以移动的新的指针。比如创建一个testing分支，你需要使用`git branch`命令。`git branch testing`。这会在当前提交对象上创建一个指针。那么，git又是如何知道当前在哪一个分支上呢？也很简单，他有一个名为HEAD的特殊指针，注意它和其他版本控制系统的HEAD概念完全不同。在Git中，它是一个指针，指向当前所在的本地分支。注意创建后仅仅创建一个分支，并不会自动切换到分支上去。

可以使用 git log 命令查看各个分支当前所指的对象，提供这一功能的参数是 `--decorate`

## 分支切换

要切换到一个已经存在的分支，需要使用`git checkout`命令，`git checkout testing`这样 HEAD 就指向 testing分支了。那么，这样的实现方式会有什么好处呢？如果此时提交进行一次提交，你的testing分支将会向前移动，但是master分支却没有，它仍然指向运行git checkout时所指的对象，这就有意思了，现在我们切换回master分支。`git checkout master`这条命令做了两件事情，一是使HEAD指回master，二是将工作目录恢复成master分支所指向的文件快照内容。也就是说，现在做修改的话，项目将开始于一个比较旧的版本，这就是忽略testing分支所做的修改，以便于向另一个方向进行开发。

分支切换会改变目录中的文件，在切换分支的时候，一定要注意工作目录中的文件会改变。如果是切换到一个较为旧的分支，你的工作目录会恢复到该分支最后一次提交的样子。如果Git不能干净利落地完成这个任务，它将禁止切换分支。

这样，在两个分支方向上进行开发，项目的提交历史已经产生了分叉。因为新建了一个分支，并切换过去进行了一些操作，随后又切换回master分支进行了另外一些工作，上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟的时候将它们合并起来，而所有这些工作，你需要的命令只有branch、checkout、commit


你可以使用git log命令查看分叉历史。运行`git log --oneline --decorate --graph --all`会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。       

由于Git的分支实质上仅仅是包含所指对象校验和的文件，所以它的创建和销毁都异常高校，创建一个新分支就相当于向一个文件中写入 41 个字节。这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支的时候，将所有的项目文件都复制一遍，并保存到一个特定的目录。完成这样繁琐的过程通常需要好几秒中，有时甚至需要好几分钟，所需时间的长短完全取决于项目的规模。而在Git中任何规模的项目都能在瞬间创建新分支。同事由于每次提交都会记录父对象。所以寻找恰当的合并也是同样的简单和高效，这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。

## 分支的创建与合并

让我们来看一个简单的分支新建和分支合并的例子，实际工作中你可能会用到类似的工作流，你将经历以下步骤：

1. 开发某个网站
2. 为实现某个新的需求，创建一个分支
3. 在这个分支上开展工作

正在此时，你突然接到一个电话说由一个严重的问题需要紧急修补，此时将如下操作：

1. 切换到你的线上分支(production branch)
2. 为这个紧急任务新建一个分支，并在其中修复它。
3. 在测试通过后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支
4. 切换回最初工作的分支上继续工作

### 新建分支

首先假设正在项目上工作，并且已经有了一些提交，现在你已经决定要解决一个问题，想要创建一个分支并同时切换到那个分支上去，可以运行带有 -b 参数的 git checkout命令：`git checkout -b error`，你继续在error分支上工作并且做了一些提交，在此过程中，error分支不断向前推荐，因为你已经检出到该分支，也就是说你的 HEAD 指针指向了该分支。

现在你接到了电话有个紧急问题需要解决，有了git的帮助，你不必将这个紧急问题和error修改混在一起，你也不需要花大力气来还原关于error分支上的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支，你所要做的仅仅是切换回master分支。

但是在这么做之前，要留意当前工作目录和暂存区里哪些还没有被提交的更改，它可能会和你即将检出的分支产生冲突从而阻止git切换到该分支。最好的方法是，在你切换回分支之前，保持好一个干净的状态。有一些方法可以绕过这个问题（即，保存进度和修补提交）现在假设已经将所有的修改全部提交了，这时候可以切换回master分支了。

这个时候，你的工作目录和你开始error之前一模一样，你可以专心修复紧急问题了。请牢记：当你切换分支的时候，Git会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子，Git会自动添加